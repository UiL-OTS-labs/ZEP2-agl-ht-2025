
import agl_records;
import defs;

int find_string_index(string[] haystack, string needle) {
    int i;
    int ret = -1;

    while (i < haystack.size) {
        if (haystack[i] == needle)
            return i;
        i++;
    }

    return ret;
}

TestType[] shuffle_order = {
    TT_GRAMMATICAL,
    TT_GRAMMATICAL,
    TT_GRAMMATICAL,
    TT_GRAMMATICAL,
    TT_UNGRAMMATICAL,
    TT_UNGRAMMATICAL,
    TT_UNGRAMMATICAL,
    TT_UNGRAMMATICAL
}

int test_type_max_consecutive() {
    int max_num_consecutive = 1;
    int num_consecutive = 1;
    int i = 1;

    while(i < shuffle_order.size) {
        if (shuffle_order[i] == shuffle_order[i-1]) {
            num_consecutive++;
            if (num_consecutive > max_num_consecutive) {
                max_num_consecutive = num_consecutive;
            }
        }
        else {
            num_consecutive = 1;
        }
        i++;
    }

    return max_num_consecutive;
}


LanguageType determine_language(string stimulus) {
    LanguageType ret = LANGUAGE_NOT_SPECIFIED;
    if (find_string_index(l1_grammatical, stimulus) != -1) {
        return L1;
    }
    else if (find_string_index(l2_grammatical, stimulus) != -1) {
        return L2;
    }
    else {
        print_error("Oops stimulus: '" + stimulus + "', is neither L1 or L2\n");
        flush_error();
    }
    return ret;
}

string[] l1_grammatical = {
    "baa_daa_meu",
    "baa_geu_meu",
    "soe_daa_goo",
    "soe_geu_goo",
};

string[] l1_ungrammatical = {
    "baa_daa_goo",
    "baa_geu_goo",
    "soe_daa_meu",
    "soe_geu_meu"
}

// What is grammatical in l1 is ungrammatical in l2 and vice versa
string[] l2_grammatical = {
    "baa_daa_goo",
    "baa_geu_goo",
    "soe_daa_meu",
    "soe_geu_meu"
}

string[] l2_ungrammatical = {
    "baa_daa_meu",
    "baa_geu_meu",
    "soe_daa_goo",
    "soe_geu_goo",
};


// Based on the chosen language, store (un)grammatical stimuli names here.
// References are initialized in load_stimuli();
string[] grammatical = {};
string[] ungrammatical = {};

TestItem[] test_items = {};

string array_pop_string(string[] items) {
    string ret = items[items.size-1];
    items.size = items.size - 1;
    return ret;
}

void assign_string_array(string[] to, string[] from) {
    to.size = from.size;
    int i = 0;
    while (i < to.size) {
        to[i] = from[i];
        i++;
    }
}

void array_append_string(string[] array, string item) {
    array.size = array.size + 1;
    array[array.size - 1] = item;
}

void append_test_item(TestItem[] items, TestItem item) {
    items.size = items.size + 1;
    items[items.size - 1] = item;
}

TestItem
pop_test_item(TestItem[] items)
{
    TestItem ret = items[items.size - 1];
    items.size = items.size - 1;
    return ret;
}

TestItem
create_grammatical() {

    string stimulus = array_pop_string(grammatical);

    LanguageType language = determine_language(stimulus);

    TestItem item;
    item.test_type = TT_GRAMMATICAL;
    item.sndfn     = stimulus;
    item.language  = language;
    item.id        = -1;

    return item;
}

TestItem
create_ungrammatical() {

    string stimulus = array_pop_string(ungrammatical);

    LanguageType language = determine_language(stimulus);

    TestItem item;
    item.test_type = TT_UNGRAMMATICAL;
    item.sndfn     = stimulus;
    item.language  = language;
    item.id        = -1;

    return item;
}

// Selects the right list of grammatical and ungrammatical stimuli for language
// L1 or L2.
// And shuffles the grammatical and ungrammatical items.
void
prepare_stimuli_lists() {
    string slt = to_lowercase(expdb.participant.get_enum_field("language"));

    if (slt == "l1") {
        assign_string_array(grammatical, l1_grammatical);
        assign_string_array(ungrammatical, l1_ungrammatical);
    }
    else if (slt == "l2") {
        assign_string_array(grammatical, l2_grammatical);
        assign_string_array(ungrammatical, l2_ungrammatical);
    }
    else {
        print_error("Oops, language seems invalid");
    }

    grammatical.shuffle(0,-1);
    ungrammatical.shuffle(0,-1);
}

void
set_stimulus_direction() {
    int i;
    string first = expdb.participant.get_enum_field("first_side");

    if (first != "left" && first != "right") {
        print_error("oops first_side ain't left nor right...\n");
        flush_error();
    }

    Direction next_side = first == "left" ? LEFT_SIDE : RIGHT_SIDE;

    i = 0;
    while (i < test_items.size) {
        test_items[i].sound_direction = next_side;
        next_side = next_side == LEFT_SIDE ? RIGHT_SIDE : LEFT_SIDE;
        i++;
    }
}

void
prepare_test_items() {
    string GRAMMATICAL = "grammatical";
    string UNGRAMMATICAL = "ungrammatical";

    string grammar_first = expdb.participant.get_enum_field("first_grammar");

    test_items.size = 0; // clear test items

    // Always shuffle at least once. Otherwise you might end up with a
    // order that will never balance the left/right - grammatical/ungrammatical
    // right
    shuffle_order.shuffle(0, -1);
    while ((grammar_first == GRAMMATICAL && shuffle_order[0] != TT_GRAMMATICAL) 
        || (grammar_first == UNGRAMMATICAL && shuffle_order[0] != TT_UNGRAMMATICAL)
        || (test_type_max_consecutive() != 2)) {
        shuffle_order.shuffle(0, -1);
    } 

    int i = 0;
    while (i < NUM_TEST_TRIALS) {
        TestItem item;
        if (shuffle_order[i] == TT_GRAMMATICAL) {
            item = create_grammatical();
        }
        else if (shuffle_order[i] == TT_UNGRAMMATICAL) {
            item = create_ungrammatical();
        }
        else {
            print_error("Oops test items ain't grammatical nor ungrammatical");
            flush_error();
        }

        append_test_item(test_items, item);

        i++;
    }
    if (test_items.size != NUM_TEST_TRIALS) {
        print_error("Oops expected to have precisely 8 test_items here.");
    }
}

void
set_trial_numbers() {
    int i = 0;
    while (i < test_items.size) {
        test_items[i].id = i + 1;
        i++;
    }
}

int count_grammatical_side_items(TestItem[] items, Direction dir, TestType tt) {
    int count = 0;
    int i = 0;
    while(i < items.size) {
        if (items[i].test_type == tt && items[i].sound_direction == dir)
            count++;
        i++;
    }
    return count;
}

bool meets_constraints() {
    Direction direction;
    int count;

    if (test_items.size != NUM_TEST_TRIALS) {
        return false;
    }

    direction = LEFT_SIDE;
    TestType tt = TT_GRAMMATICAL;

    count = count_grammatical_side_items(test_items, direction, tt);
    if (count != 2) {
        print_error(
            "Oops number of " + direction + "/" + tt + " count =  " + count +"\n"
        );
        flush_error();
        return false;
    }

    return true;
}

int load_stimuli() {

    while (!meets_constraints()) {
        prepare_stimuli_lists();
        prepare_test_items();

        set_stimulus_direction();
        set_trial_numbers();
    }

    return OK;
}

